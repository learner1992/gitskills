类的头信息+类体
1.什么是类：class修饰的字符即是类名



2.一个java文件可以写多个类，编译会产生对应的多个.class文件，该.class文件名即是类名。公开类的类名必须和文件名一致，有且至多只有一个。一个文件内类的名字不能相同。编译器编译了xxx.java文件，不一定会生成xxx.class文件（因为不一定有public 公共类定义）

3.Java程序分类：java小应用程序，java应用程序：一个java程序往往有多个类组成，当该程序中的某个类包含了主方法，那么该程序就是应用程序
什么是方法：只要看到小括号就是一个方法
方法的作用：   多个执行语句组合在一起叫做语句块，这个语句块就是一个方法体。执行语句必须出现在语句块或方法内
什么是语句块：一对大括号括起来的执行语句组合，不包含在方法内{}

什么是主方法：主方法就是main方法，有专门的格式
主方法的特殊之处（方法头固定，不能更改）：主方法是Java应用程序的入口，如果没有主方法，那么就不能执行；当程序启动会首先找到main方法的方法体，如果main方法的方法体执行完毕，那么整个程序就结束了；如果要执行其它方法，则需要方法调用
Jvm->内存->执行main，虚拟机自动寻找main方法，其他方法调用固定格式方法名()，程序执行是顺序结构
3.Java中注释：注释在源码中保留，但是经过编译阶段就会被舍弃，即字节码文件中不含有注释，使用反编译工具可以检测
	换行为"\r\n"
	文档注释以/**  开头 以*/结尾 中间注释多行内容；文档注释可以被提炼出来（这是与普通多好注释的区别），使用javadoc.exe javadoc  HelloWorld.java(源文件）
4.转义字符的内容和作用：把一个字符进行转义，使它具有特殊的功能，需要使用\进行转义
	\n 换行符
	\b  退格  光标向前移动一位，默认光标应该在下一个输出的地方
	\r 回车 将光标移到本行起始位置  所以回车换行应为\r\n
	\t 制表符 把光标移到下一个表格，一个表格有八个位置，所以会跳过剩余的位置，至少跳一个位置，最多跳八个
5.什么是标识符：
	由字母，下划线，美元符号作为开头，后跟字母，下划线，美元符号，数字所组成的组合，不可以是Java中的关键字（汉字也是标识符）
	关键字就是Java中的保留字，一共50个，全部为纯英文字母小写
	标识符就是用来命名的 给类，方法，变量，包，接口etc命名
6.变量：变化的量
	内存中的一个存储单元，是进程中的基本存储单位
	变量要先声明再使用，声明意味着会在内存中开辟空间
	变量的三要素：变量的类型，名字，作用范围
		1.java是一门强类型的语言，变量的声明必须指明该变量的类型；变量的类型可以不同，这个类型指的是数据类型
		变量可以存储不同类型的数据，但是某个变量只能存储某个类型
		2.变量名称需要符合标识符规则，两个变量如果作用范围完全相同则不可同名（成员变量和局部变量可以同名）
			如果两个局部变量的作用范围有交集，则不能同名，尤其涉及语句块的情况
			变量的类型不能决定变量名是否相同
			成员变量之间不可同名
			名字相等，一定使用局部变量
			
		3.变量的种类：根据变量的声明位置和作用范围可以分成两种->局部变量（在方法或语句块之内声明的变量）->成员变量（全局变量：在类的  类体中，在方法及语句块之外声明的变量）
			局部变量和成员变量的区分：1.声明位置不同，2.作用范围不同，3.默认值 初始值（局部变量声明之后没有初始值，成员变量有初始值）
			局部变量的作用范围：
				方法内的局部变量：从声明处开始，一直到方法的结束；
				语句块内的局部变量：从声明处开始，一直到语句块结束
			成员变量的作用范围是整个类
		4.给变量赋值：java中=是赋值符号，有四种赋值方式：先声明后定义，和声明定义一起。默认值是根据变量的数据类型来决定默认值
7.数据类型：
	十进制转为二进制：除基倒取余(不断除以2）
	基本数据类型：（整型，浮点型，字符型可以统称为数值型）
		可以分为2类8种（数值型，逻辑类型），也可以分成4类8种
		两个整型数字进行算术运算符会自动转换为至少是int型，两个byte相加即是int型，而不是byte型
		1.整型：默认是int类型
			1.字节型
				byte：占一个字节，-0规定为-128  最高位为符号位。可以把不超过范围的值直接赋值给byte型
			2.短整型
				short：占两个字节，-32768-32767   2^15
			3.整型
				int：占四个字节，-2^31-2^31-1
				例：int a=2147483650;这里会报错是后面的数值报错，与前面无关，因为所有整数默认是int型，需要把数字转成其他类型如1L
			4.长整型
				long：占八个字节，以上都是负零规定为最小值；如果要把一个整数声明为long类型，需要在后面加上大写或小写的L，l
		2.浮点型（小数）：默认为double类型
			1.单精度：float ，占四个字节，不可以把double的值赋值给float类型，即使不超过范围
				单精度含义：保证7位有效数字，不保证第八位有效，也不保证第八位无效。当值超过八位就会使用科学计数法
				注意：尽量不要使用浮点数进行判断和运算
				如果要声明float类型，后面加F或f
			2.双精度：double 占八个字节
				含义：保证15位有效数字，不保证第16位有效，也不保证第16位无效
				注意：双精度操作选取前14位
				如果要声明double类型，可以在后面加D或d
		3.字符型：占用两个字节，很多时候可以把它看成常量，String+char=String
			含义：由一对单引号括起来的单个字符，用char表示，是Unicode中有的，字符型也是数值型，对应的数值就是位置号
			没有符号位，所以可以表示0-65535；0位是null
			在不超过范围的情况下可以把int直接赋值给char
		4.布尔类型（逻辑类型）：
			用boolean,普通情况占四个字节，如果作为数组的元素占用一个字节
			取值范围：true，false
	自动转换：char->int->long->float->double
	强制转换：类型转换不适用布尔型；必须要给常量，不能是变量名：int i=1;byte b=i;error
			编译器的安全检查机制：编译器在编译期间不知道变量的取值范围 byte b=1; byte y=b+1;error
			如果加final进行修饰，表示为常量（1.不可变，2.编译期就确定值）
			强制转换会引起的问题：1.数据可能会丢失
	引用数据类型：
		类，接口，数组
		String：String是位于java.lang包下的类，是引用数据类型
				java中不可变字符串是由String类管理的
				在+号的两端由一个是字符串时，此时+用作连接成字符串
8.ascii共128个，是unicode中前128个
9.运算符：
	算术运算符：如果两个数据或者两个变量进行算术运算符的运算，那么结果的最低级别是int->byte +short = int,其他都是向上看齐
			%取模=取余
			字面常量
			Int i=1; i=i++; 最终i为2，赋值为最后的动作，且最后是用临时空间的值赋值给变量
			
	赋值运算符：扩展赋值运算符隐含了一个强制转换，转换为对应的左边类型byte y+=1；
	关系运算符：两个数据或变量使用关系运算符进行运算，那么该式就是关系表达式，所有的关系表达式都会返回一个布尔型
	逻辑运算符：可以做位运算
			  &：逻辑与->
			&&：短路与->只要为假就不再向后判断
			|：逻辑或->
			||：短路或->只要为真就不再向后判断
			！：非
			^：异或->不同为真，相同为假
	位运算符:只能操作整数
		左移：x<<y=x*2^y;5<<2=5*2^2,等于5*4，这时候效率比较高
		右移：x>>y：对负数操作并不是真正的除以2的幂，是结果的向下取整
		无符号右移>>>:对正数做除以2，提高效率
	三目运算符：?: (x==max||x==min)?:
	
	赋值运算符和条件运算符是级别最低
	Java中基本数据类型转换的规则
	赋值：自动转换和强制转换；
	算术运算：数据类型的提升；
10.运算符的优先级：
	小括号最高优先级：
	单目乘除为关系，逻辑三目后赋值
	单目：单目运算符+ –(负数) ++ -- 等 
	乘除：算数单目运算符* / % + - 
	为：位移单目运算符<< >> 
	关系：关系单目运算符> < >= <= == != 
	逻辑：逻辑单目运算符&& || & | ^ 
	三目：三目单目运算符A > B ? X : Y 
	后：无意义，仅仅为了凑字数 
	赋值：赋值= 
	逻辑运算符中&>^>|>&&>||
	！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符
	算术运算符优先于位运算符
			instanceof：是关系运算符
11.静态的方法可以直接用类名.方法名直接使用，不是静态类，则需要new对象后由对象引用
	Math 类 java.lang包  ：规定使用此包下面的类不需要导包；Math.random()
	Scanner 类java.util包
	switch后面的值可以是byte，short，int，char，String(java1.7加入)
				不可以是：long，boolean，float，double（本来浮点型就不能用来判断，但可以转换成String类型判断）
	方法的可变参数：
		格式：method(int…n){}，
		特性：
			1.方法支持可变参数，可以有多个类型的参数，但是可变参数必须位于最后面
			2.  …之后的变量是编译器把参数打包成数组了（但又不完全等同于数组），参数可以是0或多个
			3.可变参数不完全等同于数组类型，两种都写->编译器会跑错，不能用此区分重载
				例:show(int…i),show(int[]i)
			4.可变参数的调用问题->如果参数符合要求，优先调用没有实现可变参数的方法
12.无法访问的语句有一般都是编译器进行安全检查的时候发现有些语句永远无法执行，如continue和while(true)之后的语句
13.break总是终止自己能够作用到的最里层的switch或者while语句，比如switch嵌套在while中，switch中的break只终止自己
14.编程风格：
	常量：每个单词都要大写，多个单词使用_进行区分
	类 接口 ：每个单词首字母大写
	变量，方法：首单词小写，之后每个单词的首字母大写
	
	
	Import java.util.Scanner;
	Scanner sc = new Scanner(System.in)
	Int i=sc.nextInt();
	String s=sc.next();
		next()：会自动过滤掉前面的空格和后面的空格，直到有效字符，
		Nextline():遇到enter就结束，包含空格符
	Math.random();返回一个[0,1)随机小数，double型
	if语句可以无限制嵌套，但一般不超过三层；
	
对于m.n的格式还可以用如下方法表示（例） 
char ch[20]; 
printf("%*.*s\n",m,n,ch); 
15.方法的形参列表等同于在方法内部声明了一个局部变量；
	Static 方法只能调用static方法和static成员变量
	java只有值传递：引用数据类类型只不过传递的是地址值，虽然地址是引用
	方法重载的内容：不可以通过修饰符，返回值类型来区分，因为调用的时候是用 类名.方法名无法区分是哪个
					只和形参列表有关系，方法的参数不同才可以重载
						1）个数不同  2）参数类型  3）不同类型参数的顺序不同
	实参是传递给方法

eclipse快捷键大全：
F3 F5 F6 F7 F8
栈内存溢出：递归调用栈中不断加入方法创建栈帧
递归内存占用过多，编程简单，运行效率高：要求效率且无视内存消耗
	在递归分析的时候要注意剩下的n-1是下次递归的对象，而不是1
16.数组：
	数组是一堆具有相同名称，相同类型，不同索引的号的数据所组成的有序集合
	所有数组一经创建，长度永远不变，int[]a;这个只是声明，下面赋值之后才是创建
	数组也是引用数据类型，数组中元素的默认值是数组类型决定的
	所有的引用数据类型，默认值都是null，如果说默认值是null的话，那么输出该引用数据结果是null
		************************
		如何判断数组里的真实元素有多少个可以利用这个特性判断到为null的值的时候break就可以得到数组实际个数
		这个特性不一定好用，因为数组元素默认值是数组类型决定的，int型的默认值就是0，不是null，引用类型才是null
		************************
		目前只用普通数组要创建自适应的数组长度需要先声明一个初始化长度，再根据输入判断长度是否超过数组长度，
		如果超过了就再new一个新数组，长度增加，然后把旧数组值赋值过去，再把新值加入末尾
		如果用该引用进行调用方法和属性时会报空指针错误。
		对于局部变量可以先赋值为null，然后就可以正常使用
	数组应先声明再使用，声明之后还需要进行初始化
		1）静态初始化：int []a={1,2,3},声明和赋值必须在同一行
		2）动态初始化：int []a;  a=new int[10]，之后再赋值（常用）
		3）动静结合初始化：有静态初始化的特点，还有动态初始化的特点，int[]a; a=new int[]{1,2,3}
	数组的初始化内存分配：
		数组在空间中是连续的一块


		增强for循环遍历数组：foreach语句：for(int i:array)
		数组的常用操作：
			数组的扩容：
				使用Arrays.copyOf或者Arrays.copyOfRange()
		数组的特点：
			只能存储同一种类型的数据
			一旦初始化，长度不可改变
			数组中的元素与元素之间的内存地址是连续的
		数组的优缺点：
			优点：
				按照索引查询元素速度快
				能存储大量数据
				按照索引遍历数组方便
			缺点：
				根据内容查找元素速度慢
				数组的大小一经确定不能改变
				数组只能存储一种类型的数据
				增加删除元素效率慢
				未封装任何方法，所有操作需要用户自定义
		排序
		所有引用输出的都是地址，但是只要实现了tostring方法，输出的就不是地址而是值，数组没有实现，所有直接打印是地址
		冒泡排序的优化：
			基础的冒泡排序是用a[j]和a[j+-1]进行比较j从0开始，因为每次最后一个数是最终结果了
			1）从最后向前比较
			2）加入哨兵（此时是相邻比较交换）
		选择排序：用a[i]和a[j]进行比较
			基础版是每次a[i]和a[j]比较之后立即交换，交换次数比较多
			优化1版：每次排序都将最小的值的索引保留，比较到最后时候交换值到对应的首位，减少交换次数提高效率，每次比较也是用记住的那  
					个值一次向下比
			优化2版：
		arrays类：专门提供操作数组的方法
		Equals ：可以判断对象的值相等，不需要考虑地址的问题
			数组名空间存储的是数组对象地址，故直接==都是false，两个数组中有一个是null则肯定不会相等
			地址相同的肯定相等
			哈希：
			只有容器，集合之类才有hashcode（考虑到一种情况，对容器进行插入时，如何判断容器中已有此对象）
			优点是可以提供快速的插入操作和查找操作，时间复杂度是O(1)【基于比较的查询效率低】
			哈希表也有一些缺点它是基于数组的，数组创建后难于扩展某些哈希表被基本填满时，性能下降得非常严重，所以程序虽必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。
			put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。
			equals返回true的对象，hashcode必定相等
			hashcode值相等的对象，equals不一定相等
			在重写equals方法的同时，必须重写hashCode方法
				在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。
			散列技术既是一种存储方法，也是一种查找方法
			整个散列过程其实就是两步。
			(1) 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
			(2) 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。由于存取用的是同一个散列函数， 因此结果当然也是相同的。
			
			为什么是31? 31是个神奇的数字，因为任何数n * 31就可以被JVM优化为 (n << 5) -n,移位和减法的操作效率要比乘法的操作效率高的多。
			
		Copyof(int[]a,int length) ：
			会使用到System.arrayCopy这个native方法
		copyOfRange(int[]a,int from,int to)
		Tostring:只会把数组里的内容输出，如果是二维数组，则因为里面存放的是内部数组的地址，打印的只是内存地址
		Sort:
		hashcode：
			每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！
		二分查找法：大量数据面前效率高，但必须要先排序
		二维数组：
			等长数组，不等长数组（可以用静态和动静结合的定义方式定义）
			在内存中的位置
			
			外层的数组的每个元素都是数组，多个一维数组组合在一起
			Int[][]a;int[]a[];
			1)静态初始化：声明初始化必须在同一行
				Int[][]a={{1}{2}}
			2）动态初始化：必须声明外数组的长度，内数组的长度可以指定，也可以不指定
				Int[][]a;
				a=new int[1][2];
				int[][] arr3 = new int[5][];//五行的长度//这时候只定义了外层，内层是null
			3）动静初始化：
				Int[][]a;a=new int[][]{{1},{2}}
			二维数组的遍历：
				1）普通for循环
				2）两层foreach循环

			
17.查看源码的三种方式：
	1）F3
	2）ctrl+左键
	3）debug模式（上述两种无法进入源码时使用，如调用接口类）
18.native修饰的方法是本地方法
	本地方法特性：
		1）没有方法体（目前认为是eclipse不给看）
		2）方法的内部实现不是用java写的，一般是C
			
			
			
	扩展：
	jvm三个特性：多线程，动态链接，异常处理
	Java体系结构中，最下层是移植接口（由适配器和javaos组成，保证java体系可以跨平台），上面是一层虚拟机，虚拟机上层是java基本类和基本api，他们都具有扩展性
	类库主要包括：java包，javax，org扩展包
	a%b=a-(a/b)*b   注：浮点数取余，结果是带小数的浮点数
	
	在java之中，break和continue都可以用来跳出当前循环，但是两者的主要区别是：
	当循环执行到break语句时，就退出整个循环，然后执行循环外的语句。
	当循环语句执行到continue时，当次循环结束，重新开始下一轮循环。如果已经是最后一轮循环了，那么这是的continue就与break效果一样了。
	
	1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制. 
	2. 栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。） 
	3. 堆：存放所有new出来的对象。 
	4. 静态域：存放静态成员（static定义的） 
	5. 常量池：存放字符串常量和基本类型常量（public static final）。 
	6. 非RAM存储：硬盘等永久存储空间 
	对于栈和常量池中的变量可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期可以确定，当没有引用指向数据时，这个数据就消失，堆中对象由垃圾回收器负责回收，因此大小和生命周期不确定，具有很大的灵活性
	对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好（直接用双引号定义）的就存储在常量池中，如果是new出来的才确定的就存储在堆中，对于equals相等的字符串，在常量池中永远只有一份，在堆中由多份
	对于通过new产生一个字符串（假设为”china”）时，会先去常量池中查找是否已经有了”china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。这也就是有道面试题：String s = new String(“xyz”);产生几个对象？一个或两个，如果常量池中原来没有”xyz”,就是两个。 
	对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。 
	调用方法时，要求实参和形参的个数相同，类型完全相同  如果是int型调用float型参数方法是可以的，即是可以向上转型调用
	面向对象
	static 关键字学习	代表静态的，首先被加载，且只被加载一次，加载的过程有先有后，后加载的是非static
		1.作用：①修饰属性：被修饰的属性又称为类属性|静态字段，依附于类存在，不依附于对象存在，存储在方法区中的静态区；
		              访问方式：不考虑权限的话->类名.属性名  ||  对象名.属性名（不推荐）
		②方法：被static修饰的被称为类方法||静态方法，从属于类，不从属于对象
		              访问方式：类名.方法名||对象名.方法名（不推荐）
		        static 修饰的方法是属于类的,该方法的调用者可能是一个类,而不是对象.如果使用的是类来调用而不是对象,则 this就无法指向合适的对象.所以static 修饰的方法中不能使用this. （有对象才能有this，而static可以先于对象存在）
		③代码块：{}括起来的语句组合又称为语句块，static修饰的叫做静态代码块
		        语句块的执行顺序是从上到下依次执行（静态加载之后，构造器之前）
		            一个类可以有任意个代码块
		   作用：可以代替构造器进行赋值（有些类特殊没有构造器，此时就可以用代码块进行赋值）
		应用场景：程序运行需要一些基础的必要的条件，往往用静态代码块来做
		
		④类
	总结	1.静态的成员只可以访问静态的成员，非静态成员可以访问静态和非静态的成员
		        2. 
	普通属性和类属性分配空间有何不同	普通属性等对象创建之后分配空间
		类属性在类加载阶段就分配了空间（方法区中的静态域）
		普通属性是每个对象独一份的，而类属性是共享的，只有一份，且只被加载一次（可以使用new对象的构造函数证明）
		经测试，类属性永远只有一份，无论是本类生产的对象还是用子类生成的对象，只要是static，都共享一个
		main方法也是static ，但是会在static属性和static语句块调用结束之后才会被调用
		static内存不会被垃圾回收，一直到程序结束才回收
	
	1.前提：导包
		静态方法：类名.方法名
		普通方法：创建对象，对象.方法名
	2.学习面向对象的意义：（有一个代理，有一个对象可以直接协助完成功能，这个对象可以不让你面向过程，（代理的内部是面向过程的））
					面向对象编程不可能抛弃面向过程，但是简化了纯面向过程的编程操作，提高了代码复用性
		1）明白类的构造
		2）明白如何去设计类
		3）创建类的对象，面向对象编程
	3.对象：
		1）什么是对象和类：对象是类的一个实例，类是抽象的，对象是具体的，类是对对象的抽象，类把对象和共性抽象并描述出来
					对象是通过类创建的，对象拥有类赋予的功能和特性
					类是对现实生活中一类具有共同特征的事物的抽象，实质是一种数据类型
		2）对象如何创建：根据类创建的对象，类就是模板或图纸
						1）抽离共性
						2）生成模板
						3）构建对象
		3）对象的作用
	4.封装：
		1.合理的封装一个类要有五个部分分别是：属性，构造器，设定器，访问器，功能方法
		2.合理的封装类要有权限的限制
		构造方法：
			构造方法可以有return语句，但一般不用，加的话只是提前结束（return除了中断方法继续执行并返回值，还可以只中断方法而不返回值）
			this关键字：this总是指向当前对象本身（它是个特殊的隐式属性，存储的是本对象的地址）
					1.this.属性 指向当前对象的属性而不是局部变量（可以区分成员变量和局部变量）
					2.this.方法 可以调用当前对象的方法（不加也行，和普通方法调用一样）
					3.this([实参])  调用构造器，必须放在第一行
	
					
			无参构造器用private修饰，不生成空的对象
		访问器：public 类型 get?属性（）{
					return this.属性;}
		功能方法：
			每个对象被输出时都会隐式调用 对象.toString方法
			每个类都有toString方法
			需要定义什么方法，就定义什么方法
			equals 是比较同一类型 引用数据类型是否相等
继承	作用：提高代码的重用性；完善类的管理
	java只支持单继承，extends
特性	1.父类的属性和方法都赋予子类（属性，方法，功能方法，构造器，访问器）
	        父类无法获得子类对象属性
	2.父类私有的private不会继承给子类（在权限的控制下，子类无法继承：private，default）
	Super()调用父类构造器需要放在第一行，即使没有调用父类构造器，也会默认调用父类无参构造器；
	java创建对象的三个步骤就是，申请内存，调用构造方法，返回对象引用。每当你new一个子类对象的时候，子类对象都隐式内置了一个父类对象。所以一定会调用父类的某个构造器
	New 子类构造器会先执行父类的构造器，如果父类还有父类的构造器，则先执行爷爷类
	即是先依次压栈，然后自上而下执行
	java中的类，如果没有显示的定义继承了某个类那么就隐式的继承了Object（即所有的类都是直接或者简介继承了Object类）
执行构造器之后	创建对象并不是单纯发创建了子对象，而是先创建内嵌的父类对象，父类对象以内部对象存储
	所有的super和this存储的都是内存首地址0x12
	每个对象都拥有自己的一份属性，拥有自己的父类对象，父类对象拥有自己的一份父类属性
super和this一样都是对象隐含的属性，存放的是本对象的首地址
父类有了某属性，子类就不用再定义了，因为父类的设定器，访问器只会修改访问自己的属性值

			
	
	
	
	
	










1.super关键字：隐含属性
	super总是指向父类对象本身，代表了向上追溯
	super.属性 当子类有相同的属性时，super.属性代表使用的是父类属性
	super()调用父类构造器，给父类属性赋值
	super.方法  子类有方法时，调用父类方法
	在调用子类构造器时，肯定会调用父类构造器，如果不指定有参父类构造器，则会默认自动调用父类无参构造器，也可以手动调用父类无参构造器，所以必须定义父类无参构造器
2.权限
	类：只有public和default
	方法
	属性
3.方法的重写（好处：符合子类的需求，发生在父类子类之间）
	1.子类重写的方法大于等于父类的方法权限
	2.返回值类型必须小于等于父类的方法返回值类型：要么是类型相同，要么是子类类型
	3.抛出的异常必须小于等于的父类的异常类型
	4.父类类型可以存储子类对象，父类只拥有自己本身的成员，并替换被子类重写的方法！！此处应注意
		对象本身仍然拥有子类定义的成员，但是无法使用；如果将父类对象再强转成子类型成员，则无法使用的成员又可以重新使用
		子类成员可以自动存储给父类的变量（引用）
		父类成员不可以自动给子类变量赋值，需要强制转换：子类型=（子类型）父类型；如果强转的类型不匹配就会出现异常（必须保证是真正的子类类型才能正常使用）
		类型转换不涉及boolean型，只有数值型
		例：Father father=new Son(); 
		如果父类对象存储的是子类对象那么 father instanceof Son 返回的是true
		为什么指向子类对象的父类引用无法调用子类种独有的方法或者属性，即使对象本身还是子类对象
			因为编译器认为你是父类引用，不应该使用子类的属性
4.final修饰符：最终的不变的
		修饰的成员是不变的，只读的，如果final修饰的是引用类型的变量，只是说指向的地址是不变的，地址里面的值是任意变换的；如果修饰的是基本类型变量，则是栈中的值不变
		作用：
			1）修饰局部变量，该局部变量变成了常量，不能修改值
			2）修饰属性：如果final修饰了成员变量
				1.必须显式的赋值
				2.如果在声明定义时没有显式的赋值，那么必须在每个构造器中显式的赋值（这里显示赋值不是说要赋具体的值，this.id=id这种也是可以的）
			3）修饰方法：该方法不能被重写
			4）修饰类：不能被继承
		
5.多态：编译时多态，运行时多态
	一个指令多种状态（代码复用，父类必须也实现了方法功能）
	Java多态的实现：
		1）必须实现继承
		2）子类重写了父类的方法（权限，返回值，方法名）
		3）父类的引用（变量）指向了子类的对象（自动向上转型）（在这里如果对父类引用使用instanceof则它同时是 
		      父类和子类的对象
6.组合：多个类作为属性存在于一个新类种
		减少代码的书写
		组合和继承的不同：
			1）都是从外界获取了代码，减少了自己的代码量，不支持多继承
7.抽象类：
	什么是抽象类：
		抽象类是一种比较抽象的类，不是完全具体的类，是部分抽象的类，和普通的类有很大的区别
		类中包含了一定的抽象，所以不能实例化对象
	什么时候需要抽象类：
		当去描述一个类的时候，发现这个类的某些地方是无法描述的，那么就写成抽象类一
	如何声明定义一个抽象类：
		使用abstract 关键字声明定义抽象类
		格式：
			【修饰符】abstract class类名{}
	什么是抽象方法：
		abstract修饰的方法就是抽象方法
		抽象方法特性？必须有abstract，没有语句块 方法体 结尾用;分号标识，没有大括号
		总结：定义了一个抽象方法，仍然具有普通方法的大部分特性，但是是一种不能用的方法
	什么是实现抽象方法：
		把方法给予方法体，方法体可以为空，但不介意这么做，因为没有意义‘
		把抽象关键字去掉
	抽象方法和抽象类：
		1）如果一个正常的类有了抽象方法，那么必须声明为抽象类
		2）抽象类可以有0个或多个抽象方法
	abstract：部分抽象（因为有部分实际的方法，有部分抽象方法）
		抽象类的特性：
			1）不能实例化对象
			2）可以有构造器（虽然不能直接使用，子类中可以用super调用）
			3）可以有普通方法和抽象方法
			4）可以被继承，只支持单继承 
		抽象类的作用：
			1）继承
			2）可以定义静态的方法给外界使用
		抽象类被继承时的特性：
			1）如果抽象类有抽象方法，那么子类有两个选择
				1.必须实现抽象类实现的所有的抽象方法
				2.如果不全部实现，或者一个都不实现，那么子类也必须声明为抽象类
			2）正常类继承了抽象类，那么子类可以创建子类的对象，子类可以继承父类的属性方法，构造器
			3） 
8.接口
	接口是一组要求，一套规范 是对java类的要求和规范
	接口不是类，但是后缀名仍然是.java
	接口的作用：
		1）制定了一套规则让某些java类来遵守
		2）用于和第三方的交互
		3）弥补了java单继承的缺陷
	如何让java类来遵守接口的规范：
		java类实现（继承）接口  implements 
		java类实现了接口有什么要求：
			1）如果java类实现了接口，那么必须实现所有接口的抽象方法
			2）如果java类不实现所有的抽象方法，那么这个类必须声明为抽象类
			3）类成为接口的子类 正常类仍然可以创建对象 属于该接口的子类型
				接口类型 接口类型的变量=实现类的对象（多态性） 
	如何创建一个接口：
		使用interface关键字：
			格式:[修饰符] interface 接口名字{}
	接口内容：
		1.公共的静态常量 public static final，即使三个修饰符都不加，系统自动加上缺省的修饰符
		2.公共的抽象方法：即使不加public abstract修饰方法，系统默认就是抽象方法
	java类实现接口有什么好处：
		1）实现了多继承 只能说实现了一半，只能说多了父类型
		2）获得了N多的规则
	java类继承java类和实现接口的区别：
		继承java类可以获得属性 构造器 方法 父类型（即可以用父类型接收自己类对象）
		实现接口可以获得父类型 规则
	接口的特性：
		1
	抽象类和接口的区别：
		1）抽象类可以有构造器，接口不可以有
		2）抽象类可以有正常的属性，接口只能有公共的静态常量
		3）抽象类可以有正常的方法，接口只能有公共的抽象方法
		1.8新特性：
